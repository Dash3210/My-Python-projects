<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Ball Trajectory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d2115; /* Dark green background */
        }
        canvas {
            background-color: #a3b86c; /* Green from the image */
        }
        .control-panel {
            background-color: #1f2937; /* A dark gray for the panel */
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto flex flex-col gap-6">
        <h1 class="text-3xl font-bold text-center text-yellow-200">Cricket Ball Trajectory</h1>
        <p class="text-center text-gray-300 -mt-4">A bowler's perspective. Adjust speed, swing, spin, and bowling angle.</p>
        
        <!-- Canvas for the animation -->
        <div class="w-full aspect-[16/7] bg-black rounded-xl shadow-2xl border-2 border-gray-600 overflow-hidden">
            <canvas id="trajectoryCanvas"></canvas>
        </div>

        <!-- Combined Panel for controls and metrics -->
        <div class="w-full control-panel p-4 rounded-xl border border-gray-700 flex flex-col md:flex-row md:items-center gap-4">
            <div class="flex-grow grid grid-cols-2 md:grid-cols-4 gap-x-6 gap-y-2 text-sm text-gray-300">
                <div class="flex justify-between items-center">
                    <span class="font-bold">Speed (KPH):</span>
                    <span id="speedLabel" class="font-mono bg-cyan-100 text-cyan-800 px-2 py-1 rounded">120</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="font-bold">Swing Force:</span>
                    <span id="swingLabel" class="font-mono bg-purple-100 text-purple-800 px-2 py-1 rounded">0.000</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="font-bold">Spin Force:</span>
                    <span id="spinLabel" class="font-mono bg-orange-100 text-orange-800 px-2 py-1 rounded">0.00</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="font-bold">Final Deviation:</span>
                    <span id="deviationLabel" class="font-mono bg-pink-100 text-pink-800 px-2 py-1 rounded">0 px</span>
                </div>
            </div>

            <div class="flex-shrink-0 grid grid-cols-3 gap-2">
                <button id="stanceButton" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">Stance: RHB</button>
                <button id="approachButton" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">Over Wicket</button>
                <button id="resetButton" class="bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-bold py-2 px-4 rounded-lg transition-colors">Re-bowl</button>
            </div>
        </div>

        <!-- Sliders -->
        <div class="p-6 bg-gray-800 rounded-xl border border-gray-700 grid grid-cols-1 md:grid-cols-3 gap-6">
            <div>
                <label for="speedSlider" class="block mb-2 font-medium text-gray-300">Speed</label>
                <input id="speedSlider" type="range" min="4" max="12" value="8" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-400">
            </div>
            <div>
                <label for="swingSlider" class="block mb-2 font-medium text-gray-300">Swing (In the air)</label>
                <input id="swingSlider" type="range" min="-0.05" max="0.05" value="0" step="0.001" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-400">
            </div>
            <div>
                <label for="spinSlider" class="block mb-2 font-medium text-gray-300">Spin (After bounce)</label>
                <input id="spinSlider" type="range" min="-0.5" max="0.5" value="0" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-orange-400">
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('trajectoryCanvas');
        const ctx = canvas.getContext('2d');

        const speedSlider = document.getElementById('speedSlider');
        const swingSlider = document.getElementById('swingSlider');
        const spinSlider = document.getElementById('spinSlider');
        const speedLabel = document.getElementById('speedLabel');
        const swingLabel = document.getElementById('swingLabel');
        const spinLabel = document.getElementById('spinLabel');
        const deviationLabel = document.getElementById('deviationLabel');
        const resetButton = document.getElementById('resetButton');
        const stanceButton = document.getElementById('stanceButton');
        const approachButton = document.getElementById('approachButton');

        let parentContainer = document.querySelector('.aspect-\\[16\\/7\\]');
        let ball = {};
        let trajectoryPath = [];
        let seamAngle = 0;
        let bounceMarker = null;
        let animationFrameId;
        
        // State variables
        let isRHB = true;
        let bowlingApproach = 'over'; // 'over' or 'around'
        let batState = { swinging: false, angle: 0, maxAngle: Math.PI / 2.5, rotationSpeed: 0.1 };

        const proportions = {
            bowlingCreaseX: 0.08,
            poppingCreaseX: 0.15,
            returnCreaseTopY: 0.2,
            returnCreaseBottomY: 0.8,
            stumpSpacing: 0.03,
            bowlingOffset: 0.1 // % of canvas height
        };

        function resizeCanvas() {
            canvas.width = parentContainer.clientWidth;
            canvas.height = parentContainer.clientHeight;
            resetAnimation();
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPitch();
            drawBat();
        }

        function drawPitch() {
            const bowlingCreaseLeftX = canvas.width * proportions.bowlingCreaseX;
            const poppingCreaseLeftX = canvas.width * proportions.poppingCreaseX;
            const bowlingCreaseRightX = canvas.width * (1 - proportions.bowlingCreaseX);
            const poppingCreaseRightX = canvas.width * (1 - proportions.poppingCreaseX);
            const returnCreaseTopY = canvas.height * proportions.returnCreaseTopY;
            const returnCreaseBottomY = canvas.height * proportions.returnCreaseBottomY;

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(bowlingCreaseLeftX, returnCreaseTopY); ctx.lineTo(poppingCreaseLeftX, returnCreaseTopY);
            ctx.moveTo(bowlingCreaseLeftX, returnCreaseBottomY); ctx.lineTo(poppingCreaseLeftX, returnCreaseBottomY);
            ctx.moveTo(poppingCreaseLeftX, returnCreaseTopY); ctx.lineTo(poppingCreaseLeftX, returnCreaseBottomY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(bowlingCreaseRightX, returnCreaseTopY); ctx.lineTo(poppingCreaseRightX, returnCreaseTopY);
            ctx.moveTo(bowlingCreaseRightX, returnCreaseBottomY); ctx.lineTo(poppingCreaseRightX, returnCreaseBottomY);
            ctx.moveTo(poppingCreaseRightX, returnCreaseTopY); ctx.lineTo(poppingCreaseRightX, returnCreaseBottomY);
            ctx.stroke();

            ctx.fillStyle = '#f0e68c';
            const stumpRadius = 4;
            const stumpSpacing = canvas.height * proportions.stumpSpacing;
            
            ctx.beginPath(); ctx.arc(bowlingCreaseLeftX, canvas.height/2-stumpSpacing, stumpRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(bowlingCreaseLeftX, canvas.height/2, stumpRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(bowlingCreaseLeftX, canvas.height/2+stumpSpacing, stumpRadius, 0, Math.PI * 2); ctx.fill();
            
            ctx.beginPath(); ctx.arc(bowlingCreaseRightX, canvas.height/2-stumpSpacing, stumpRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(bowlingCreaseRightX, canvas.height/2, stumpRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(bowlingCreaseRightX, canvas.height/2+stumpSpacing, stumpRadius, 0, Math.PI * 2); ctx.fill();
        }

        function drawBat() {
            const poppingCreaseX = canvas.width * (1 - proportions.poppingCreaseX);
            const batWidth = 12;
            const batHeight = 60;
            
            const yOffset = isRHB ? - (canvas.height * proportions.stumpSpacing * 2.5) : (canvas.height * proportions.stumpSpacing * 2.5);
            const pivotX = poppingCreaseX;
            const pivotY = canvas.height / 2 + yOffset;

            ctx.save();
            ctx.translate(pivotX, pivotY);
            ctx.rotate(isRHB ? -batState.angle : batState.angle);
            
            // Draw relative to the pivot
            ctx.fillStyle = '#d2b48c'; // Light wood color
            ctx.strokeStyle = '#8b4513'; // Darker wood for outline
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(0, -batHeight / 2, batWidth, batHeight);
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function resetAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            let startYOffset = canvas.height * proportions.bowlingOffset;
            let startY = bowlingApproach === 'over' ? canvas.height / 2 - startYOffset : canvas.height / 2 + startYOffset;

            ball = {
                x: canvas.width * proportions.poppingCreaseX + 15,
                y: startY,
                radius: 8,
                dx: parseFloat(speedSlider.value),
                dy: 0,
                swing: parseFloat(swingSlider.value),
                spin: parseFloat(spinSlider.value),
                hasBounced: false,
                preBounceDx: 0,
                preBounceDy: 0,
                isFinished: false
            };

            batState.swinging = false;
            batState.angle = 0;
            trajectoryPath = [{x: ball.x - 10, y: ball.y}];
            seamAngle = 0;
            bounceMarker = null;
            updateLabels();
            animate();
        }

        function updateLabels() {
            speedLabel.textContent = (parseFloat(speedSlider.value) * 15).toFixed(0); 
            swingLabel.textContent = parseFloat(swingSlider.value).toFixed(3);
            spinLabel.textContent = parseFloat(spinSlider.value).toFixed(2);
            const deviation = trajectoryPath.length > 0 ? trajectoryPath[trajectoryPath.length - 1].y - canvas.height / 2 : 0;
            deviationLabel.textContent = `${deviation.toFixed(0)} px`;
        }
        
        function drawBall(x, y, radius) {
            ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#b30000';
            ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 8; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 4;
            ctx.fill();
            ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
            ctx.save();
            ctx.translate(x, y); ctx.rotate(seamAngle);
            ctx.beginPath(); ctx.arc(0, 0, radius, -Math.PI / 2.5, Math.PI / 2.5);
            ctx.strokeStyle = '#fff5e1'; ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function drawSwingArrow() {
            const startX = canvas.width * proportions.poppingCreaseX;
            let startYOffset = canvas.height * proportions.bowlingOffset;
            const startY = bowlingApproach === 'over' ? canvas.height / 2 - startYOffset : canvas.height / 2 + startYOffset;
            const swing = parseFloat(swingSlider.value);
            if (Math.abs(swing) < 0.001) return;

            ctx.beginPath(); ctx.moveTo(startX, startY);
            const controlX = startX + 50, controlY = startY + swing * 1000;
            const endX = startX + 100, endY = startY + swing * 2000;
            ctx.quadraticCurveTo(controlX, controlY, endX, endY);
            ctx.strokeStyle = "rgba(168, 85, 247, 0.7)"; ctx.lineWidth = 2;
            ctx.stroke();
            const angle = Math.atan2(endY - controlY, endX - controlX);
            ctx.save(); ctx.translate(endX, endY); ctx.rotate(angle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, -5); ctx.lineTo(-10, 5); ctx.closePath();
            ctx.fillStyle = "rgba(168, 85, 247, 0.7)"; ctx.fill();
            ctx.restore();
        }
        
        function redrawFullScene() {
            drawScene();
            drawSwingArrow();
            if (bounceMarker) {
                 ctx.beginPath(); ctx.arc(bounceMarker.x, bounceMarker.y, 5, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fill();
            }
            if (trajectoryPath.length > 1) {
                ctx.beginPath(); ctx.moveTo(trajectoryPath[0].x, trajectoryPath[0].y);
                for (let i = 1; i < trajectoryPath.length; i++) ctx.lineTo(trajectoryPath[i].x, trajectoryPath[i].y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3; ctx.stroke();
            }
            if (ball.isFinished && bounceMarker) {
                const startX = bounceMarker.x, startY = bounceMarker.y;
                const preBounceSpeed = Math.sqrt(ball.preBounceDx * ball.preBounceDx + ball.preBounceDy * ball.preBounceDy);
                const dirX = ball.preBounceDx / preBounceSpeed; const dirY = ball.preBounceDy / preBounceSpeed;
                const projectionLength = canvas.width * 0.4;
                const projectedX = startX + dirX * projectionLength; const projectedY = startY + dirY * projectionLength;
                ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(projectedX, projectedY);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)'; ctx.lineWidth = 2; ctx.setLineDash([4, 8]); ctx.stroke(); ctx.setLineDash([]);
            }
            if (trajectoryPath.length > 1) {
                const finalX = trajectoryPath[trajectoryPath.length-1].x; const finalY = trajectoryPath[trajectoryPath.length-1].y;
                ctx.beginPath(); ctx.moveTo(finalX, finalY); ctx.lineTo(finalX, canvas.height/2);
                ctx.strokeStyle = 'rgba(236, 72, 153, 0.9)'; ctx.lineWidth = 2; ctx.setLineDash([3, 5]); ctx.stroke(); ctx.setLineDash([]);
            }
            drawBall(ball.x, ball.y, ball.radius);
        }

        function animate() {
            if (!ball.isFinished) {
                ball.dx = parseFloat(speedSlider.value); ball.swing = parseFloat(swingSlider.value); ball.spin = parseFloat(spinSlider.value);
                ball.dy += ball.swing; ball.x += ball.dx; ball.y += ball.dy;
                seamAngle += ball.dx * 0.05;
                trajectoryPath.push({ x: ball.x, y: ball.y });

                const swingTriggerX = canvas.width * (1 - proportions.poppingCreaseX) - 30;
                if(ball.x > swingTriggerX && !batState.swinging) {
                    batState.swinging = true;
                }

                const bounceX = canvas.width * 0.65;
                if (ball.x > bounceX && !ball.hasBounced) {
                    ball.preBounceDx = ball.dx; ball.preBounceDy = ball.dy;
                    ball.dy += ball.spin; ball.hasBounced = true;
                    bounceMarker = { x: ball.x, y: ball.y };
                }
                if (ball.x > canvas.width * (1 - proportions.bowlingCreaseX) - ball.radius) ball.isFinished = true;
            }
            
            if (batState.swinging && batState.angle < batState.maxAngle) {
                batState.angle += batState.rotationSpeed;
            }

            redrawFullScene();
            updateLabels();
            
            animationFrameId = requestAnimationFrame(animate);
        }

        stanceButton.addEventListener('click', () => {
            isRHB = !isRHB;
            stanceButton.textContent = isRHB ? 'Stance: RHB' : 'Stance: LHB';
            redrawFullScene(); // Redraw immediately to show change
        });

        approachButton.addEventListener('click', () => {
            bowlingApproach = bowlingApproach === 'over' ? 'around' : 'over';
            approachButton.textContent = bowlingApproach === 'over' ? 'Over Wicket' : 'Around Wicket';
             if(ball.isFinished) resetAnimation();
        });

        window.addEventListener('resize', resizeCanvas);
        resetButton.addEventListener('click', resetAnimation);
        [speedSlider, swingSlider, spinSlider].forEach(slider => {
            slider.addEventListener('input', () => { if(ball.isFinished) resetAnimation(); });
        });

        resizeCanvas();
    </script>
</body>
</html>

